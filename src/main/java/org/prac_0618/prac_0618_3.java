package org.prac_0618;

// 문제 : `무기 a무기 = new 칼();` 가 실행되는 세부과정을 자세히 쓰세요.
public class prac_0618_3 {
    public static void main(String[] args) {
        // * double d = 5.5; 의 처리과정
        // 1 : 실수 5.5가 생긴다.
        // 2 : 오직 실수만 담을 수 있는 변수 d가 생성된다.
        // 3 : d는 5.5가 자신안에 들어 올 수 있는지 판단한다.(가능)
        // 4 : d변수에 실수 5.5가 들어간다.
        double d = 5.5;

        // * double dd = 5; 의 처리과정
        // 1 : 정수 5가 생긴다.
        // 2 : 오직 실수만 담을 수 있는 변수 dd가 생성된다.
        // 3 : dd는 5가 자신안에 들어 올 수 있는지 판단한다.
        // 4 : 5는 정수이기 때문에 들어 올 수 없다고 판단한다.(불가능)
        // 5 : dd가 아쉬워하는 5에게 이렇게 이야기 합니다. `니가 실수로 변환될 수 있다면 들어올 수 있다.`
        // 6 : 5는 자신의 형태를 버리고 실수화 한다. 즉 5.0으로 변신하다.(캐스팅, 또는 형변환)
        // 7 : dd로 5.0이 들어간다.
        double dd = 5;

        // * int i = 5.5; 의 처리과정
        // 1 : 실수 5.5가 생긴다.
        // 2 : 오직 정수만 담을 수 있는 변수 i가 생성된다.
        // 3 : i는 5.5가 자신에게 담길 수 있는지 체크한다.(불가능)
        // 4 : i는 아쉬워하는 5.5에게 이렇게 이야기 합니다. `니가 정수가 된다면 들어올 수 있다.`
        // 5 : 5.5는 도저히 불가능 요구를 받고 치명적인 에러를 발생시킨다.(캐스팅 불가능 으로 인한 에러)
        //int i = 5.5;


        //무기 a무기 = new 칼();
        // * 위 코드의 처리 과정
        // 오직 객체만 살수 있는 힙 영역에 칼이라는 클래스를 통해 객체가 생성된다.
        // 생성된 칼이라는 객체는 자기자신을 스스로 조종할 수 있는 리모콘(this)를 가지고 태어난다.
        // 현 상태는 오직 칼 객체만 자신을 조종할 수 있다.
        // 무기 클래스를 통해 변수 a무기가 생성된다.
        // => a무기는 태어날때 쓰레기 리모콘을 가지고 태어난다. why? 객체와 연결되어있지 않기 때문에.
        // 칼 객체 리모콘이 오직 무기 리모콘만 들어갈 수 있는 a무기에 들어가려고 시도한다.
        // a무기 변수는 칼 객체 리모콘에게 무기리모콘이 맞는지 질문한다.
        // 칼 리모콘은 자기 자신이 가리키고 있는 대상이 무기인지 자문한다. Answer: No!
        // a무기 리모콘은 칼 객체 리모콘에게 무기리모콘으로 변신할 의향이 있는지 묻는다.
        // 칼 리모콘이 칼과 무기는 호환되지 않기 때문에 불가능하다고 대답한다.
        // 칼과 무기는 클래스가 달라 서로 연결될 수 없다.



    }
}

//class 무기 {
//
//}
//
//class 칼 {
//
//}


